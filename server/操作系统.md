>一、引论

 1. 什么是**操作系统**？
操作系统(Operating System, OS)是直接配置在计算机硬件上的最基本的系统**软件**，负责管理计算机的**软硬件资源**，实现对计算机**资源**的**抽象**，为用户提供方便**易用**的接口。

 2. **操作系统四个目标：**
	有效性、方便性、可扩充性、开放性
	
 3. **操作系统三大作用：**
	OS作为用户与计算机硬件系统之间的**接口**
	OS作为计算机系统**资源**的**管理者**
	OS实现了对计算机资源的**抽象**
	
 4. **历史上的三种基本类型的操作系统**：多道批处理系统、分时系统、实时系统。

 5. **实时系统|分时系统的比较**                                                                                           
<1>**及时性**：实时信息处理系统对实时性的要求与分时系统类似，都是以人能接收的等待时间来确定，而**实时**控制系统的及时性，则是与控制对象所要求的开始截止时间或者完成截至时间来确定的，一般为**秒级到毫秒级。**
<2>**交互性**：实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的**专用服务程序**，它不像分时系统那样能向终端用户提供**数据处理和资源的共享**。
<3>**可靠性**：分时系统虽然也要求可靠，相比之下，**实时**系统则要求系统具有**高度**的可靠性，因为任何差错都可能带来巨大的经济损失，甚至是无法预料的灾难。往采取了**多级容错**措施来保障系统的安全性及数据的安全性。

 6. 操作系统的**四大基本特征** ： 并发      共享      虚拟      异步
 其中**并发**和**共享**是最基本的特征，又是**互为存在**的条件。
**并发**性是**最重要**的特征。


----------

>二、进程

 7. 为什么要引入**进程**？
为了使程序能**可靠**的并发，于是把程序包装成进程，**程序**以进程实体的方式驻留在内存，**轮流**占用**CPU**执行。

 8. **进程的特征**：结构特征(进程实体)、动态性(生命周期)、并发性、异步性、独立性。

 9. **进程的三种基本状态及其转换关系**
>![1](http://img.blog.csdn.net/20160615221009229)


 10. **进程控制块(PCB)是进程存在的唯一标志**。为什么呢？
<1>:为了描述和控制进程的运行，系统为每个进程定义了一个数据结构--进程控制块PCB(Process Control Block),它是进程实体的一部分，是操作系统中最重要的**记录型数据**结构。
<2>:PCB中记录了操作系统所需的、用于描述进程当前情况以及**控制进程**运行的全部**信息**。进程控制块的**作用**是使一个在多道程序环境下不能独立运行的程序，**成为**一个能与其他程序**并发**执行的进程。也就是OS根据**PCB来对并发执行的进程进行控制和管理的。**
<3>:在调度某些进程后，要根据其PCB中所保存的处理机状态信息，设置该进程**恢复**运行的现场，并根据PCB中的程序和数据内存**始址**，找到其程序和数据，进程在执行过程中，当需要与之合作的进程是实现**同步、通信或者访问文件**时，也都需要访问PCB；当进程由于某种原因而**暂停**执行时，又需要将其**断点**的处理机环境保存在PCB中
<4>:所以在进程的整个生命周期中，系统总是通过PCB对进程进行控制，所以，系统是根据**进程的PCB而不是任何别的什么而感知到该进程的存在**，所以PCB是进程存在的唯一标志。

 11. **进程同步**：诸进程在并发执行时存在直接和间接两种相互制约关系。

 12. **临界资源与临界区**：每个进程中访问临界资源的那段代码称为临界区。

 13.  **同步机制四准则**：空闲让进，忙则等待，有限等待，让权等待。

 14. **进程同步 – 信号量(Semaphore)机制**
整型信号量与记录型信号量从用户角度来看是一样的，均包含两个原子操作wait(S)和signal(S)，或称PV原语。wait操作申请一个单位资源，将S值减少1；signal操作释放一个单位资源，将S值增加1。

 整型信号量因未遵循**让权等待**准则而被记录型信号量取代。

 **互斥信号量**的初值是1。资源信号量的当前值代表该类临界资源的可用数量，注意：若资源信号量的当前值是负数，则该资源当前可用数量为0，且其**绝对值**代表正在排队阻塞等待该资源的进程数量。例如与打印机相关的信号量S=-3，则打印机当前可用数量为0台，且有3个进程正在排队阻塞等待该打印机。
信号量可用于实现进程间**互斥及同步。**

 15. **进程间通信**(IPC)
信号量机制是卓有成效的同步工具，但不是卓有成效的进程间通信工具。于是我们介绍了三种高级进程间通信机制：管道、共享存储区、消息队列。

 16. **线程**为什么要引入线程？**比较线程与进程**？
在操作系统中引入进程的目的，是为了使多个程序能**并发执行**，以提高资源的**利用率**和系统的**吞吐量**，那么在操作系统中在引入线程，则是为了减少程序在**并发执行**时所付出的**时空开销**。使OS具有更好的**并发性**。
线程具有许多传统进程所具有的特征，所以又称为轻型进程或进程元，相应的把传统进程称为重型进程
<1>**调度**：在传统的操作系统中，作为拥有资源的基本单位和独立调度，分派的基本单位都是进程，而在引入进程的操作系统中，则把**线程**作为**调度和分派**的基本单位，而进程作为**资源拥有**的基本单位，这样线程便能轻装上阵，显著提高系统的并发性。同一进程中，线程的切换不会引起进程的切换，但是一个进程中的线程到另一个进程中的线程时， 将会引起进程的切换。
<2>**并发性**：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使操作系统具有更好的并发性，从而能够有效提高系统资源的利用率和吞吐量。
<3>**拥有资源**：不论是传统操作系统，还是引入线程的，进程都可以拥有资源，是系统中拥有资源的一个基本单位，线程自己不拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，即一个进程的代码段，数据段以及拥有的系统资源。可以供该进程中的所有线程所共享。
<4>**系统开销**：在创建或者撤销进程时， 系统都要有之创建和回收进程控制块，分配或回收资源，如内存控件和I/O设备，操作系统所付出开销明显大于线程创建或撤销的时的开销，线程切换则仅需要保存和设置绍亮的寄存器内容。由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比较容易，在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。


----------
>三、调度与死锁

 1. **高级调度**(作业调度)是从**外存**的**后备**队列中选择某个或某些作业优先调入内存。

 2. **低级调度**(进程调度)是从**内存**的**就绪**队列中选择某个进程使它优先获得CPU进入执行态。

 3. 进程调度有**抢占式**、**非抢占式**两种方式。抢占调度方式主要基于**优先权原则**、**短进程优先原则**或**时间片原则**

 4. **先来先服务调度算法**:先来先服务(First Come First Served, FCFS)调度算法是一种最简单的调度算法，既可以用于作业调度，也可以用于进程调度。有**利于长**作业（进程），**不利于短**作业（进程）；有利于CPU繁忙型的作业，不利于I/O繁忙型的作业。

 5. **短作业(进程)优先调度算法**：短作业优先(Shortest Job First, SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入**内存**运行。类似的，短进程优先(SPF)算法从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，直到其执行至完成或阻塞时再重新调度。

 6. **短作业(进程)优先调度算法优点**：相比于先来先服务调度算法，可改善平均周转时间及平均带权周转时间，尤其是对短作业，会有明显改善。从而有效**降低**作业的平均**等待**时间，提高系统**吞吐量**。
**缺点**：1）对长作业不利，会导致长作业(进程)长期不被调度(Starvation)；2）完全未考虑作业的紧迫程度；3）作业(进程)的长短是预估的，不一定准确。

 7. 产生**死锁的原因**可归结为**竞争资源**、**进程间推进顺序不当**。
 8. 产生死锁的**四大必要条件**，其中的互斥条件不仅不能摒弃，还必须保证
**1：互斥条件**（访问临界资源）
**2：请求和保持条件**。进程已保持了至少一个资源，又因提出新的资源请求而阻塞，阻塞期间对自己已获得的资源保持不放。
**3：不剥夺条件**
**4：环路等待条件**。发生死锁时，必然存在一个进程——资源的环链，即进程集合{P0,P1,…,Pn}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，…… ，Pn正在等待P0占用的资源。

 9. **处理死锁的四种方法**：**预防死锁**（摒弃哪几个必要条件？），**避免**死锁，**检测**死锁，**解除**死锁（剥夺资源、撤销进程）。

 10. **预防死锁**（**摒弃**哪几个必要条件？）
摒弃“请求与保持”条件
摒弃“不剥夺”条件
摒弃“环路等待”条件

 11. **避免死锁**( 系统的安全状态与不安全状态)
**安全状态**，是指系统能按某种进程顺序，即安全序列〈P1，P2，… ，Pn〉，来为每个进程Pi分配所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于**不安全状态**。
当系统进入不安全状态后，便有可能进而进入死锁状态。避免死锁的**实质**在于：**系统在进行资源分配时，如何避免系统进入不安全状态**。

 


